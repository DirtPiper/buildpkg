#
# Function library for buildpkg framework
# It adds support for creating Irix packages in 'inst' format
#
# Define tool programs
# *only* platform specific packaging tools should be listed here
# generic tools go in buildpkg.functions
GENDIST="/usr/sbin/gendist"

GZIP=/usr/people/tgc/bin/gzip
BZIP2=/usr/local/bin/bzip2
STRIP=/bin/true

# Configuration vars
imageconf=$buildpkgbase/scripts/image.conf
subsysconf=$buildpkgbase/scripts/subsys.conf
idbfile=$metadir/$topdir.idb
specfile=$metadir/$topdir.spec
depends=$metadir/depends
opsfile=$metadir/ops
hidefile=$metadir/hide

# Preformat manpages since Irix is not likely to have nroff available
catman=1

# Other
# Comment these declarations to get it to run with ksh
declare -a pc # Array of product categories (image.subsys)
declare -a pd # Array of matching descriptions
declare -a pctop # Array of toplevel product categories (image)
declare -a pdtop # Array of matching descriptions
declare -a reqs # Array of subsystems with prereqs
declare -a reqp # Array of prereqs (should match up with reqs)
declare -a hide # Files that should be "hidden" with nohist
declare -a opfiles # Files that should have an ops associated
declare -a opscript # Ops to associate with opfiles

#override defaults
pkgprefix=tgc_
pkgname=$pkgprefix$topdir

os=irix`$UNAME -r`
cpu=mips3

META_CLEAN="$topdir.spec $topdir.idb"

# Host specific configuration
[ -r $buildpkgbase/scripts/config.`hostname`.irix ] && . $buildpkgbase/scripts/config.`hostname`.irix

distfile=$topdir-$version-$pkgver.tgc-$os-$cpu-$pkgdirdesig.tardist

##################################################### 
# Internal helper functions
#####################################################
indent4="   "
indent8="       "
indent12="           "
indent16="               "
# fix_ver(): "normalize" a version-pkgver pair
# params: $1=version
# Removes any '.' and '-' characters from a version string
fix_ver()
{
    local ver=`echo $1 | $SED -e 's/\.//g' -e 's/-//g' -e 's/[a-zA-Z]//g'`
    echo $ver
}
# spec_header()
# param: $1=product name $2=description
spec_header()
{
	echo "product $1"
	echo "$indent4 id \"$2\""
}
spec_footer()
{
	echo "endproduct"
}
# spec_img_header()
# param: $1=image name $2=image description $3=version
spec_img_header()
{
	local nver=$(fix_ver $3)
	echo "$indent4 image $1"
	echo "$indent8 id \"$2\""
	echo "$indent8 version $nver"
	echo "$indent8 order 9999"
}
# spec_img_footer()
spec_img_footer()
{
	echo "$indent4 endimage"
}
# spec_subsys_header()
# param: $1=image $2=subsys $3=description
spec_subsys_header()
{
	echo "$indent8 subsys $2 default"
	echo "$indent12 id \"$3\""
	echo "$indent12 replaces self"
	echo "$indent12 exp $pkgname.$1.$2"
}
# spec_subsys_req()
# param: $1=prereq
spec_subsys_req()
{
    echo "$indent16 prereq ( $1 )"
}
# spec_subsys_footer()
# param: none
spec_subsys_footer()
{
    echo "$indent8 endsubsys"
}

# compute_octal()
# Description: Computes the octal value from a permission list (_rwxrwxrwx)
# param: $1=permission list
# Caveats: It won't pickup sticky bit and mandatory locking bit
compute_octal()
{
	perm=$1
	v=0; d1=0; d2=0; d3=0; d4=0
	# User part
	if [ "${perm:1:1}" == "r" ]; then
		let "v = v + 4" # set read bit
	fi
	if [ "${perm:2:1}" == "w" ]; then
		let "v = v + 2" # set write bit
	fi
	if [ "${perm:3:1}" == "x" ]; then
		let "v = v + 1" # set executable bit
	elif [ "${perm:3:1}" == "s" ]; then
		let "v = v + 1" # set executable bit
		let "d1 = d1 + 4" # Set setuid bit
	fi
	d2=$v; v=0
	# Group part
	if [ "${perm:4:1}" == "r" ]; then
		let "v = v + 4" # set read bit
	fi
	if [ "${perm:5:1}" == "w" ]; then
		let "v = v + 2" # set write bit
	fi
	if [ "${perm:6:1}" == "x" ]; then
		let "v = v + 1" # set executable bit
	elif [ "${perm:6:1}" == "s" ]; then
		let "v = v + 1" # set executable bit
		let "d1 = d1 + 2" # Set setgid bit
	fi
	d3=$v; v=0;
	# Other part
	if [ "${perm:7:1}" == "r" ]; then
		let "v = v + 4" # set read bit
	fi
	if [ "${perm:8:1}" == "w" ]; then
		let "v = v + 2" # set write bit
	fi
	if [ "${perm:9:1}" == "x" ]; then
		let "v = v + 1" # set executable bit
	fi
	d4=$v; v=0
	echo $d1$d2$d3$d4
}

# check_hide(): Should the file be "hidden"
# params: $1=file to check against $hide
check_hide()
{
    local file=$1
    for ((i=0; $i < ${#hide[@]}; i++))
    do
	if [ "${hide[$i]}" == "$file" ]; then
	    echo 1
	fi
    done
}
# check_ops(): Is there an opscript associated with $1
# param: $1=file to check
check_ops()
{
    local file=$1
    local return
    echo "file is $file" >> /tmp/debug
    for ((i=0; $i < ${#opfiles[@]}; i++))
    do
	echo "opfiles $i is ${opfiles[$i]}" >> /tmp/debug
	if [ "${opfiles[$i]}" == "$file" ]; then
	    return="${opscript[$i]}"
	fi
    done
    echo $return
}
# add_files()
# Create IDB entries for all files in a specfic product category
# Takes the following parameters
# $1 = dirname to descend into
# $2 = product_category to assign files
# $3 = permissions to set on the files we find
# $4 = user
# $5 = group
add_files()
{
	local perm=$3
	local FILES=`$FIND $1 -type f -print`
	for i in $FILES
	do
		if [ "$3" == "keep" ]; then
			permlist=`$LS -l $i | $CUT -d " " -f 1`
			perm=$(compute_octal $permlist)	
		fi
		nohist=$(check_hide $i)
		doop=$(check_ops $i)
		if [ ! -z "$nohist" ]; then
		    echo "f $perm $4 $5 ${topinstalldir:1}/$i $i $pkgname.$2 nohist" >>$idbfile
		else
		    if [ ! -z "$doop" ]; then
			echo "f $perm $4 $5 ${topinstalldir:1}/$i $i $pkgname.$2 $doop" >>$idbfile
		    else
			echo "f $perm $4 $5 ${topinstalldir:1}/$i $i $pkgname.$2" >>$idbfile
		    fi
		fi

	done
	local FILES=`$FIND $1 -type l -print`
	for i in $FILES
	do
		if [ "$3" == "keep" ]; then
			permlist=`$LS -l $i | $CUT -d " " -f 1`
			perm=`compute_octal $permlist`	
		fi
		local temp=`$LS -l $i|$CUT -d '>' -f 2`
		local symval=${temp# }
		echo "l $perm $4 $5 ${topinstalldir:1}/$i $i $pkgname.$2 symval($symval)" >>$idbfile
	done
}

# fetch_imageconf(): Fetch a list of toplevel image entries with descriptions
# params: none
# Discard the ones that we don't have any subsystems for FIXME!
fetch_imageconf()
{
    pctopidx=0
    while read image desc
    do
	pctop[$pctopidx]=$image
	pdtop[$pctopidx]=$desc
	let "pctopidx = $pctopidx + 1"
    done < $imageconf
}

# fetch_depends(): Fetch a list of subsystems and their prereqs
# params: none
#
fetch_depends()
{
    if [ -r $depends ]; then
	reqidx=0
	while read ss req
	do
	    reqs[$reqidx]=$ss
	    if [ "$req" == "auto" ]; then # auto create depend on sw.base
		nver=$(fix_ver "$version-$pkgver")
		req="$pkgname.sw.base $nver $nver"
	    fi
	    reqp[$reqidx]=$req
	    let "reqidx = $reqidx + 1"
	done < $depends
    fi
}

# fetch_ops(): Fetch ops
# params: none
# Populates the firstop and lastop variables
# and the opfiles and opscript arrays
fetch_ops()
{
    if [ -r $opsfile ]; then
	opsidx=0
	while read optype op
	do
	    case $optype in
		'firstop')
			    firstop="$op"
			    ;;
		'lastop')
			    lastop="$op"
			    ;;
	    esac
	    opfiles[$opsidx]=$optype
	    opscript[$opsidx]=$op	
	    let "opsidx = $opsidx + 1"
	done < $opsfile
    fi
}

#fetch_hide(): Fetch list of files to "hide"
#params: none
fetch_hide()
{
    if [ -r $hidefile ]; then
	hideidx=0
	while read filen
	do
	    hide[$hideidx]=$filen
	    let "hideidx = $hideidx + 1"
	done < $hidefile
    fi
}

##################################
# "external" functions
##################################
# create_idb(): Create the .idb file
# params: none
# Read each line in the subsys config file
# and check if we have a $dir in our staging area
create_idb()
{
    fetch_hide
    fetch_ops
    local index=0
    local found=0
    while read dir pdcat perm user group desc
    do
	dironly=${dir%/*}
	found=0
	if [ -d $dironly ]; then # This exists
	    add_files "$dir" $pdcat $perm $user $group
	    for i in ${pc[@]} # If $pdcat is already there then don't add it again
	    do
		if [ "$i" = "$pdcat" ]; then
		    found=1
		    break 	# It's already there so skip out
		fi
	    done
	    if [ $found -eq 0 ]; then
		pc[$index]=$pdcat
		pd[$index]=$desc
		let "index = $index + 1"
	    fi
	fi
    done < $subsysconf	
    $SORT +4u -6 < $idbfile > $metadir/idbtemp
    lines=$(wc -l < $metadir/idbtemp)
    if [ ! -z $firstop ]; then
	echo "$(head -1 $metadir/idbtemp) $firstop" > $metadir/idbtemp2
	tail +2 $metadir/idbtemp >> $metadir/idbtemp2
    else
	mv $metadir/idbtemp $metadir/idbtemp2
    fi
    if [ ! -z $lastop ]; then
	let "lines=$lines - 1"
	echo "$(head -$lines $metadir/idbtemp2)" > $idbfile
	echo "$(tail -1 $metadir/idbtemp2) $lastop" >> $idbfile
    else
	mv $metadir/idbtemp2 $idbfile
    fi
    $RM -f $metadir/idbtemp $metadir/idbtemp2
}

# create_spec(): Create the .spec file.
# params: none
# Uses pkgname & pkgdesc variables
# Iterate through pctop and for each iteration find
# all entries in pc belonging to that image
#
create_spec()
{
    fetch_imageconf
    fetch_depends
    spec_header $pkgname "$name $version-$pkgver" > $specfile
    pcsize=${#pc[@]}
    pctopsize=${#pctop[@]}
    for ((i=0; i < $pctopsize; i++))
    do
	local pcidx=0
	spec_img_header ${pctop[$i]} "${pdtop[$i]}" $version-$pkgver >> $specfile
	while [ "$pcidx" -lt "$pcsize" ]
	do
	    rv=`$EXPR match "${pc[$pcidx]}" ''${pctop[$i]}''`
	    if [ ! "$rv" -eq 0 ]; then # We got a hit!
		spec_subsys_header ${pctop[$i]} `echo ${pc[$pcidx]}|$CUT -d . -f 2` "${pd[$pcidx]}" >> $specfile
		reqsize=${#reqs[@]}
		for ((j=0; j < $reqsize; j++))
		do
		    if [ "${reqs[$j]}" == "${pc[$pcidx]}" ]; then 
			spec_subsys_req "${reqp[$j]}" >> $specfile
		    fi
		done
		spec_subsys_footer >> $specfile
	    fi
	    let "pcidx = $pcidx + 1"
	done
	spec_img_footer >> $specfile
    done
    spec_footer >> $specfile
}

# make_dist(): Create inst image
# params: $1=[shortroot]
# Run gendist to create the instimage
make_dist()
{
    local arg1=${1-'x'}
    if [ "$arg1" == "shortroot" ]; then
	sbase=$stagedir
    else
	sbase=$stagedir/$topinstalldir
    fi
    local disttmp=/tmp/disttmp$$
    $MKDIR $disttmp

    $GENDIST -rbase $topinstalldir -sbase $sbase -idb $idbfile -spec $specfile -dist $disttmp
    setdir $disttmp
    $VTAR -cf $distdir/$distfile $pkgname*

    setdir stage
    $RM -rf $disttmp
    echo "Done. Package was created as $distfile"
}

# generic_pack(): Build package using files from 'install' stage
# params: $1 - indicating whether or not the root is complete as described below
# We expect generic_install to have made $stagedir the "root" dir
# in that all paths below will be complete (ie. /usr/local/bin and not
# just bin) *unless* $1=shortroot.
generic_pack()
{   
    clean meta

    # Verify if $1 is defined
    local arg1=${1-'x'}
    case $arg1 in 
	'x')		if [ $catman -eq 1 -a -d $stagedir$topinstalldir/man ]; then
			    setdir $stagedir$topinstalldir/man	    
			    fix_man
			fi
			setdir $stagedir$topinstalldir
			create_idb
			create_spec
			make_dist 
			;;
	'shortroot')	if [ $catman -eq 1 -a -d $stagedir/man ]; then
			    setdir $stagedir/man
			    fix_man
			fi
			setdir stage
			create_idb
			create_spec
			make_dist shortroot
			;;
	'*')		error $E_BAD_ARGS generic_pack
			;;
    esac
}
